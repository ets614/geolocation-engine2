# Kubernetes Services for Detection API
# File: kubernetes/manifests/services.yaml

---
# Service for Detection API (routes to active slot via selector)
apiVersion: v1
kind: Service
metadata:
  name: detection-api-service
  namespace: default
  labels:
    app: detection-api
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8000"
spec:
  type: ClusterIP
  selector:
    app: detection-api
    slot: green  # Toggle between blue/green on deployments
  ports:
    - name: http
      port: 8000
      targetPort: 8000
      protocol: TCP
  sessionAffinity: None
  ipFamilies:
    - IPv4
  ipFamilyPolicy: SingleStack

---
# Headless Service for Detection API (for StatefulSet if needed later)
apiVersion: v1
kind: Service
metadata:
  name: detection-api-headless
  namespace: default
  labels:
    app: detection-api
spec:
  clusterIP: None
  selector:
    app: detection-api
  ports:
    - name: http
      port: 8000
      targetPort: 8000
      protocol: TCP
  publishNotReadyAddresses: true

---
# PersistentVolumeClaim for Offline Queue Storage
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: detection-queue-pvc
  namespace: default
  labels:
    app: detection-api
spec:
  accessModes:
    - ReadWriteOnce  # Single node access (pod affinity ensures single pod)
  storageClassName: fast-ssd
  resources:
    requests:
      storage: 50Gi

---
# ConfigMap for Application Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: detection-config
  namespace: default
  labels:
    app: detection-api
data:
  # TAK Server Configuration
  tak_server_endpoint: "https://tak-server.internal:8089"

  # Geolocation Accuracy Thresholds
  accuracy_threshold_green: "25"      # meters (high accuracy)
  accuracy_threshold_yellow: "100"    # meters (medium accuracy)
  accuracy_threshold_red: "500"       # meters (low accuracy)

  # Detection Sources (if auto-discovery needed)
  detection_sources: |
    {
      "sources": [
        {
          "name": "UAV-001",
          "type": "REST",
          "endpoint": "http://uav-controller.local:8080/detections",
          "auth_method": "api_key"
        },
        {
          "name": "Ground-Sensor-01",
          "type": "REST",
          "endpoint": "http://ground-sensors.local:8080/api/detections",
          "auth_method": "basic"
        }
      ]
    }

  # Application Configuration
  application_config: |
    {
      "offline_queue_max_size": 100000,
      "offline_queue_batch_size": 1000,
      "offline_sync_interval_seconds": 60,
      "confidence_min_score": 0.5,
      "operator_verification_time_minutes": 5
    }

---
# Secret for TAK Server Credentials
apiVersion: v1
kind: Secret
metadata:
  name: tak-server-credentials
  namespace: default
  labels:
    app: detection-api
type: Opaque
stringData:
  username: "tak-operator"
  password: "encrypted-password-here"  # Use sealed-secrets or external-secrets in production
  endpoint: "https://tak-server.internal:8089"

---
# Ingress for External Access
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: detection-api-ingress
  namespace: default
  labels:
    app: detection-api
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rate-limit: "1000"
    nginx.ingress.kubernetes.io/rate-limit-window: "10m"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - detection-api.internal.example.com
      secretName: detection-api-tls
  rules:
    - host: detection-api.internal.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: detection-api-service
                port:
                  number: 8000
          - path: /health
            pathType: Prefix
            backend:
              service:
                name: detection-api-service
                port:
                  number: 8000
          - path: /ready
            pathType: Prefix
            backend:
              service:
                name: detection-api-service
                port:
                  number: 8000
          - path: /metrics
            pathType: Prefix
            backend:
              service:
                name: detection-api-service
                port:
                  number: 8000

---
# NetworkPolicy: Deny All Ingress (default deny)
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: default
spec:
  podSelector: {}
  policyTypes:
    - Ingress
    - Egress

---
# NetworkPolicy: Allow Ingress from Ingress Controller
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-api-ingress
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: detection-api
  policyTypes:
    - Ingress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
      ports:
        - protocol: TCP
          port: 8000

---
# NetworkPolicy: Allow Egress to TAK Server
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-tak-egress
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: detection-api
  policyTypes:
    - Egress
  egress:
    - to:
        - podSelector:
            matchLabels:
              app: tak-server
      ports:
        - protocol: TCP
          port: 8089

---
# NetworkPolicy: Allow Prometheus Metrics Scraping
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-prometheus-scrape
  namespace: default
spec:
  podSelector:
    matchLabels:
      app: detection-api
  policyTypes:
    - Ingress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: monitoring
      ports:
        - protocol: TCP
          port: 8000
          name: http

---
# ResourceQuota for Production Namespace
apiVersion: v1
kind: ResourceQuota
metadata:
  name: production-quota
  namespace: default
spec:
  hard:
    requests.cpu: "50"
    requests.memory: "128Gi"
    limits.cpu: "100"
    limits.memory: "256Gi"
    pods: "100"
    services: "20"
    persistentvolumeclaims: "10"
  scopeSelector:
    matchExpressions:
      - operator: In
        scopeName: PriorityClass
        values: ["high", "medium"]

---
# LimitRange for Pod Resource Constraints
apiVersion: v1
kind: LimitRange
metadata:
  name: production-limits
  namespace: default
spec:
  limits:
    - type: Pod
      max:
        cpu: "2"
        memory: "4Gi"
      min:
        cpu: "100m"
        memory: "128Mi"
      default:
        cpu: "500m"
        memory: "512Mi"
      defaultRequest:
        cpu: "250m"
        memory: "256Mi"

    - type: Container
      max:
        cpu: "1"
        memory: "2Gi"
      min:
        cpu: "50m"
        memory: "64Mi"
      default:
        cpu: "500m"
        memory: "512Mi"
      defaultRequest:
        cpu: "250m"
        memory: "256Mi"

---
# PodDisruptionBudget for High Availability
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: detection-api-pdb
  namespace: default
spec:
  minAvailable: 2  # At least 2 pods must be available
  selector:
    matchLabels:
      app: detection-api
  unhealthyPodEvictionPolicy: AlwaysAllow
